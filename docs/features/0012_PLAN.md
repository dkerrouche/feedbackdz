# 0012 – Dashboard UI: Server-Backed Filters and URL State

## Brief
Implement comprehensive dashboard filter UI that connects to the enhanced server APIs from Feature 0011. Add URL state persistence so filters are bookmarkable and shareable. Replace client-only filtering with server-backed filtering while maintaining responsive UX.

## Context
Feature 0011 implemented robust server-side filtering for analytics, responses, and export APIs. Now we need to build the UI components that leverage these capabilities and provide a seamless filtering experience for business users.

## Files to Modify

### Dashboard Components
- `src/app/dashboard/page.tsx`
  - Add URL state management with `useSearchParams` and `useRouter`
  - Wire filter changes to trigger server refetches for both analytics and responses
  - Initialize filter state from URL on page load
  - Reset pagination when filters change

- `src/components/dashboard/ResponseFilters.tsx`
  - Extend filter UI to include all new filter types:
    - Audio/Text toggle switches
    - Flagged/Addressed status checkboxes
    - Enhanced search input with debouncing
    - QR code multi-select dropdown
  - Convert from client-only to server-backed filtering
  - Add filter reset and clear functionality

- `src/components/dashboard/ResponseFeed.tsx`
  - Remove client-side filtering logic (keep for instant UX feedback)
  - Update to use server-backed pagination and filtering
  - Add loading states during filter changes
  - Handle empty states when no results match filters

### New Components
- `src/components/dashboard/FilterChips.tsx`
  - Display active filters as removable chips
  - Show filter count and clear all option
  - Provide quick filter removal without opening filter panel

- `src/components/ui/MultiSelect.tsx`
  - Reusable multi-select component for QR codes, ratings, sentiments
  - Support search within options
  - Checkbox-style selection with select all/none

### Utility Functions
- `src/lib/url-state.ts`
  - Helper functions for URL state management
  - Serialize/deserialize filter objects to/from URL params
  - Handle array parameters and boolean flags
  - Provide type-safe URL state hooks

## Implementation Details

### URL State Management
The URL will reflect all active filters:
```
/dashboard?ratings=4,5&sentiments=positive,neutral&includeAudio=true&isFlagged=false&search=pizza&start_date=2025-01-01&end_date=2025-01-31
```

### Filter UI Layout
```
┌─────────────────────────────────────────────────────────┐
│ [Search Input........................] [Clear All]      │
├─────────────────────────────────────────────────────────┤
│ Date Range: [Start Date] to [End Date]                 │
├─────────────────────────────────────────────────────────┤
│ Ratings: ☐1 ☐2 ☐3 ☑4 ☑5                              │
├─────────────────────────────────────────────────────────┤
│ Sentiment: ☑Positive ☑Neutral ☐Negative               │
├─────────────────────────────────────────────────────────┤
│ Type: ☑Audio ☑Text                                     │
├─────────────────────────────────────────────────────────┤
│ Status: ☐Flagged ☐Addressed                           │
├─────────────────────────────────────────────────────────┤
│ QR Codes: [Multi-select dropdown]                      │
└─────────────────────────────────────────────────────────┘
```

### Filter State Flow
1. **URL → State**: On page load, parse URL params into filter state
2. **UI → State**: User changes filter → update local state
3. **State → URL**: Debounced URL update (300ms) 
4. **URL → Server**: Trigger API calls with new filters
5. **Server → UI**: Update analytics and responses with new data

### Debouncing Strategy
- **Search input**: 500ms debounce
- **Other filters**: 300ms debounce
- **Date range**: 500ms debounce (to allow completing both dates)
- **Immediate**: Clear all, reset filters

### API Integration
```typescript
// Analytics refetch
const { data: analytics, isLoading: analyticsLoading } = useSWR(
  `/api/analytics?${buildQueryString(filters)}`,
  fetcher
)

// Responses refetch  
const { data: responses, isLoading: responsesLoading } = useSWR(
  `/api/responses?${buildQueryString(filters)}&page=${page}&limit=${limit}`,
  fetcher
)
```

### Filter Persistence Logic
- **Session**: Filters persist during browser session
- **Bookmarkable**: URL contains complete filter state
- **Shareable**: Users can share filtered dashboard views
- **Reset**: "Clear All" returns to default state (last 30 days)

## Component Architecture

### Enhanced ResponseFilters Component
```typescript
interface ResponseFiltersProps {
  filters: ResponseFilters
  onFiltersChange: (filters: ResponseFilters) => void
  availableQRs: Array<{id: string, qr_code: string, name?: string}>
  isLoading?: boolean
}
```

### URL State Hook
```typescript
function useFilterState() {
  const searchParams = useSearchParams()
  const router = useRouter()
  
  const filters = useMemo(() => parseFiltersFromURL(searchParams), [searchParams])
  
  const updateFilters = useCallback((newFilters: ResponseFilters) => {
    const url = buildURLFromFilters(newFilters)
    router.push(url, { scroll: false })
  }, [router])
  
  return { filters, updateFilters }
}
```

### Filter Chips Component
```typescript
interface FilterChipsProps {
  filters: ResponseFilters
  onRemoveFilter: (filterKey: keyof ResponseFilters, value?: any) => void
  onClearAll: () => void
}
```

## UX Considerations

### Loading States
- Show skeleton loaders during filter changes
- Disable filter controls during API calls
- Provide visual feedback for active filters

### Performance
- Debounce filter changes to avoid excessive API calls
- Use SWR for caching and deduplication
- Implement optimistic updates where possible

### Accessibility
- Proper ARIA labels for all filter controls
- Keyboard navigation support
- Screen reader announcements for filter changes

### Mobile Responsiveness
- Collapsible filter panel on mobile
- Touch-friendly filter controls
- Horizontal scrolling for filter chips

## Validation Requirements
- Validate filter combinations (e.g., at least one of audio/text must be selected)
- Handle invalid URL parameters gracefully
- Provide user feedback for invalid filter states
- Maintain filter state consistency across page refreshes

## Testing Considerations
- Test URL state persistence across page refreshes
- Verify filter combinations work correctly
- Test debouncing behavior
- Ensure mobile filter UI is functional
- Test with various filter combinations and edge cases

## Dependencies
- Requires Feature 0011 (enhanced server APIs)
- Uses existing `useRealtimeResponses` hook
- Depends on current dashboard layout structure
- May need SWR or React Query for data fetching

## Out of Scope
- Realtime analytics refresh (Phase 3)
- Advanced charts (Phase 4)
- Bulk actions UI
- Filter presets/saved filters
